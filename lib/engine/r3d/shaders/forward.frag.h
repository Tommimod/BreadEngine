#ifndef FORWARD_FRAG_H
#define FORWARD_FRAG_H

#ifdef __cplusplus
extern "C" {
#endif

static const char FORWARD_FRAG[] = "#version 330 core\n#define M_PI 3.1415926535897931\n#define M_TAU 6.2831853071795862\n#define M_INV_PI .3183098861837907\nvec3 M_Rotate3D(vec3 v,vec4 q){vec3 t=2.*cross(q.xyz,v);return v+q.w*t+cross(q.xyz,t);}mat3 M_OrthonormalBasis(vec3 n){float sgn=n.z>=0.?1.:-1.;float a=-1./(sgn+n.z);float b=n.x*n.y*a;vec3 t=vec3(1.+sgn*n.x*n.x*a,sgn*b,-sgn*n.x);vec3 bt=vec3(b,sgn+n.y*n.y*a,-n.y);return mat3(t,bt,n);}vec2 M_OctahedronWrap(vec2 val){return(1.-abs(val.yx))*mix(vec2(-1.),vec2(1.),vec2(greaterThanEqual(val.xy,vec2(0.))));}vec3 M_DecodeOctahedral(vec2 encoded){encoded=encoded*2.-1.;vec3 normal;normal.z=1.-abs(encoded.x)-abs(encoded.y);normal.xy=normal.z>=0.?encoded.xy:M_OctahedronWrap(encoded.xy);return normalize(normal);}vec2 M_EncodeOctahedral(vec3 normal){normal/=abs(normal.x)+abs(normal.y)+abs(normal.z);normal.xy=normal.z>=0.?normal.xy:M_OctahedronWrap(normal.xy);normal.xy=normal.xy*.5+.5;return normal.xy;}vec3 M_NormalScale(vec3 normal,float scale){normal.xy*=scale;normal.z=sqrt(1.-clamp(dot(normal.xy,normal.xy),0.,1.));return normal;}float M_HashIGN(vec2 pos){const vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(pos,magic.xy)));}float PBR_DistributionGGX(float cosTheta,float alpha){float a=cosTheta*alpha;float k=alpha/(1.-cosTheta*cosTheta+a*a);return k*k*(1./M_PI);}float PBR_GeometryGGX(float NdotL,float NdotV,float roughness){return .5/mix(2.*NdotL*NdotV,NdotL+NdotV,roughness);}float PBR_SchlickFresnel(float u){float m=1.-u;float m2=m*m;return m2*m2*m;}vec3 PBR_ComputeF0(float metallic,float specular,vec3 albedo){float dielectric=.16*specular*specular;return mix(vec3(dielectric),albedo,vec3(metallic));\n}\n#define LIGHT_FORWARD_COUNT 8\n#define LIGHT_DIR 0\n#define LIGHT_SPOT 1\n#define LIGHT_OMNI 2\nvec3 L_Diffuse(float cLdotH,float cNdotV,float cNdotL,float roughness){float FD90_minus_1=2.*cLdotH*cLdotH*roughness-.5;float FdV=1.+FD90_minus_1*PBR_SchlickFresnel(cNdotV);float FdL=1.+FD90_minus_1*PBR_SchlickFresnel(cNdotL);return vec3(M_INV_PI*(FdV*FdL*cNdotL));}vec3 L_Specular(vec3 F0,float cLdotH,float cNdotH,float cNdotV,float cNdotL,float roughness){roughness=max(roughness,1e-3);float alphaGGX=roughness*roughness;float D=PBR_DistributionGGX(cNdotH,alphaGGX);float G=PBR_GeometryGGX(cNdotL,cNdotV,alphaGGX);float cLdotH5=PBR_SchlickFresnel(cLdotH);float F90=clamp(50.*F0.g,0.,1.);vec3 F=F0+(F90-F0)*cLdotH5;return cNdotL*D*F*G;}vec3 IBL_FresnelSchlickRoughness(float cosTheta,vec3 F0,float roughness){return F0+(max(vec3(1.-roughness),F0)-F0)*pow(clamp(1.-cosTheta,0.,1.),5.);}float IBL_GetSpecularMipLevel(float roughness,float numMips){return roughness*roughness*(numMips-1.);}float IBL_GetSpecularOcclusion(float NdotV,float ao,float roughness){return clamp(pow(NdotV+ao,exp2(-16.*roughness-1.))-1.+ao,0.,1.);}vec3 IBL_GetMultiScatterBRDF(sampler2D brdfLut,float NdotV,float roughness,vec3 F0,float metalness){vec2 brdf=texture(brdfLut,vec2(NdotV,roughness)).rg;vec3 FssEss=F0*brdf.x+brdf.y;float Ess=brdf.x+brdf.y;float Ems=1.-Ess;vec3 Favg=mix(F0+(1.-F0)/21.,F0,metalness);vec3 Fms=FssEss*Favg/(1.-Favg*Ems+1e-5);float msStrength=mix(1.,.8,metalness);return FssEss+Fms*Ems*msStrength;}struct Light{vec3 color;vec3 position;vec3 direction;float specular;float energy;float range;float near;float far;float attenuation;float innerCutOff;float outerCutOff;float shadowSoftness;float shadowMapTxlSz;float shadowDepthBias;float shadowSlopeBias;lowp int type;bool enabled;bool shadow;};in vec3 vPosition;in vec2 vTexCoord;in vec4 vColor;in mat3 vTBN;in vec4 vPosLightSpace[LIGHT_FORWARD_COUNT];uniform sampler2D uTexAlbedo;uniform sampler2D uTexEmission;uniform sampler2D uTexNormal;uniform sampler2D uTexORM;uniform samplerCube uShadowMapCube[LIGHT_FORWARD_COUNT];uniform sampler2D uShadowMap2D[LIGHT_FORWARD_COUNT];uniform float uEmissionEnergy;uniform float uNormalScale;uniform float uOcclusion;uniform float uRoughness;uniform float uMetalness;uniform vec3 uAmbientLight;uniform vec3 uEmissionColor;uniform samplerCube uCubeIrradiance;uniform samplerCube uCubePrefilter;uniform sampler2D uTexBrdfLut;uniform vec4 uQuatSkybox;uniform bool uHasSkybox;uniform float uSkyboxAmbientIntensity;uniform float uSkyboxReflectIntensity;uniform Light uLights[LIGHT_FORWARD_COUNT];uniform float uAlphaCutoff;uniform vec3 uViewPosition;\nuniform float uFar;\n#define SHADOW_SAMPLES 8\nconst vec2 VOGEL_DISK[8]=vec2[8](vec2(.250000,0.),vec2(-.319290,.292496),vec2(0.048872,-.556877),vec2(.402444,.524918),vec2(-.738535,-.130636),vec2(.699605,-.445031),vec2(-.234004,.870484),vec2(-.446271,-.859268));layout(location=0)out vec4 FragColor;layout(location=1)out vec4 FragAlbedo;layout(location=2)out vec4 FragNormal;layout(location=3)out vec4 FragORM;float ShadowOmni(int i,float cNdotL){Light light=uLights[i];vec3 lightToFrag=vPosition-light.position;float currentDepth=length(lightToFrag);vec3 direction=normalize(lightToFrag);float bias=light.shadowSlopeBias*(1.-cNdotL*.5);bias=max(bias,light.shadowDepthBias*currentDepth);currentDepth-=bias;mat3 OBN=M_OrthonormalBasis(direction);float r=M_TAU*M_HashIGN(gl_FragCoord.xy);float sr=sin(r);float cr=cos(r);mat2 diskRot=mat2(vec2(cr,-sr),vec2(sr,cr));float shadow=0.;for(int j=0;j<SHADOW_SAMPLES;++j){vec2 diskOffset=diskRot*VOGEL_DISK[j]*light.shadowSoftness;vec3 sampleDir=normalize(OBN*vec3(diskOffset.xy,1.));float sampleDepth=texture(uShadowMapCube[i],sampleDir).r*light.far;shadow+=step(currentDepth,sampleDepth);}return shadow/float(SHADOW_SAMPLES);}float Shadow(int i,float cNdotL){Light light=uLights[i];vec4 p=vPosLightSpace[i];vec3 projCoords=p.xyz/p.w;projCoords=projCoords*.5+.5;if(any(greaterThan(projCoords.xyz,vec3(1.)))||any(lessThan(projCoords.xyz,vec3(0.)))){return 1.;}float bias=light.shadowSlopeBias*(1.-cNdotL);bias=max(bias,light.shadowDepthBias*projCoords.z);float currentDepth=projCoords.z-bias;float r=M_TAU*M_HashIGN(gl_FragCoord.xy);float sr=sin(r);float cr=cos(r);mat2 diskRot=mat2(vec2(cr,-sr),vec2(sr,cr));float shadow=0.;for(int j=0;j<SHADOW_SAMPLES;++j){vec2 offset=diskRot*VOGEL_DISK[j]*light.shadowSoftness;shadow+=step(currentDepth,texture(uShadowMap2D[i],projCoords.xy+offset).r);}return shadow/float(SHADOW_SAMPLES);}void main(){vec4 albedo=vColor*texture(uTexAlbedo,vTexCoord);if(albedo.a<uAlphaCutoff)discard;vec3 emission=uEmissionEnergy*(uEmissionColor*texture(uTexEmission,vTexCoord).rgb);vec3 orm=texture(uTexORM,vTexCoord).rgb;float occlusion=uOcclusion*orm.x;float roughness=uRoughness*orm.y;float metalness=uMetalness*orm.z;vec3 F0=PBR_ComputeF0(metalness,.5,albedo.rgb);vec3 N=normalize(vTBN*M_NormalScale(texture(uTexNormal,vTexCoord).rgb*2.-1.,uNormalScale));if(!gl_FrontFacing)N=-N;vec3 V=normalize(uViewPosition-vPosition);float NdotV=dot(N,V);float cNdotV=max(NdotV,1e-4);vec3 diffuse=vec3(0.);vec3 specular=vec3(0.);for(int i=0;i<LIGHT_FORWARD_COUNT;i++){if(!uLights[i].enabled){continue;}Light light=uLights[i];vec3 L=vec3(0.);if(light.type==LIGHT_DIR)L=-light.direction;else L=normalize(light.position-vPosition);float NdotL=dot(N,L);if(NdotL<=0.)continue;float cNdotL=min(NdotL,1.);vec3 H=normalize(V+L);float LdotH=max(dot(L,H),0.);float cLdotH=min(LdotH,1.);float NdotH=max(dot(N,H),0.);float cNdotH=min(NdotH,1.);vec3 lightColE=light.color*light.energy;vec3 diffLight=L_Diffuse(cLdotH,cNdotV,cNdotL,roughness);diffLight*=lightColE*(1.-metalness);vec3 specLight=L_Specular(F0,cLdotH,cNdotH,cNdotV,cNdotL,roughness);specLight*=lightColE*light.specular;float shadow=1.;if(light.shadow){if(light.type==LIGHT_OMNI){shadow=ShadowOmni(i,cNdotL);}else{shadow=Shadow(i,cNdotL);}}if(light.type!=LIGHT_DIR){float dist=length(light.position-vPosition);float atten=1.-clamp(dist/light.range,0.,1.);shadow*=atten*light.attenuation;}if(light.type==LIGHT_SPOT){float theta=dot(L,-light.direction);float epsilon=(light.innerCutOff-light.outerCutOff);shadow*=smoothstep(0.,1.,(theta-light.outerCutOff)/epsilon);}diffuse+=diffLight*shadow;specular+=specLight*shadow;}vec3 ambient=uAmbientLight;if(uHasSkybox){vec3 kS=IBL_FresnelSchlickRoughness(cNdotV,F0,roughness);vec3 kD=(1.-kS)*(1.-metalness);vec3 Nr=M_Rotate3D(N,uQuatSkybox);ambient=kD*texture(uCubeIrradiance,Nr).rgb;ambient*=uSkyboxAmbientIntensity;}else{ambient=(1.-F0)*(1.-metalness)*ambient;ambient+=F0*uAmbientLight;}ambient*=occlusion;if(uHasSkybox){vec3 R=M_Rotate3D(reflect(-V,N),uQuatSkybox);const float MAX_REFLECTION_LOD=7.;float mipLevel=IBL_GetSpecularMipLevel(roughness,MAX_REFLECTION_LOD+1.);vec3 prefilteredColor=textureLod(uCubePrefilter,R,mipLevel).rgb;float specularOcclusion=IBL_GetSpecularOcclusion(cNdotV,occlusion,roughness);vec3 specBRDF=IBL_GetMultiScatterBRDF(uTexBrdfLut,cNdotV,roughness,F0,metalness);vec3 spec=prefilteredColor*specBRDF*specularOcclusion;float edgeFade=mix(1.,pow(cNdotV,.5),roughness);spec*=edgeFade;specular+=spec*uSkyboxReflectIntensity;}diffuse=albedo.rgb*(ambient+diffuse);FragColor=vec4(diffuse+specular+emission,albedo.a);FragAlbedo=vec4(albedo.rgb,1.);FragNormal=vec4(M_EncodeOctahedral(N),vec2(1.));FragORM=vec4(occlusion,roughness,metalness,1.);}";

#define FORWARD_FRAG_SIZE 9004

#ifdef __cplusplus
}
#endif

#endif // FORWARD_FRAG_H
