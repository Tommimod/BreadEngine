#ifndef LIGHTING_FRAG_H
#define LIGHTING_FRAG_H

#ifdef __cplusplus
extern "C" {
#endif

static const char LIGHTING_FRAG[] = "#version 330 core\n#define M_PI 3.1415926535897931\n#define M_TAU 6.2831853071795862\n#define M_INV_PI .3183098861837907\nvec3 M_Rotate3D(vec3 v,vec4 q){vec3 t=2.*cross(q.xyz,v);return v+q.w*t+cross(q.xyz,t);}mat3 M_OrthonormalBasis(vec3 n){float sgn=n.z>=0.?1.:-1.;float a=-1./(sgn+n.z);float b=n.x*n.y*a;vec3 t=vec3(1.+sgn*n.x*n.x*a,sgn*b,-sgn*n.x);vec3 bt=vec3(b,sgn+n.y*n.y*a,-n.y);return mat3(t,bt,n);}vec2 M_OctahedronWrap(vec2 val){return(1.-abs(val.yx))*mix(vec2(-1.),vec2(1.),vec2(greaterThanEqual(val.xy,vec2(0.))));}vec3 M_DecodeOctahedral(vec2 encoded){encoded=encoded*2.-1.;vec3 normal;normal.z=1.-abs(encoded.x)-abs(encoded.y);normal.xy=normal.z>=0.?encoded.xy:M_OctahedronWrap(encoded.xy);return normalize(normal);}vec2 M_EncodeOctahedral(vec3 normal){normal/=abs(normal.x)+abs(normal.y)+abs(normal.z);normal.xy=normal.z>=0.?normal.xy:M_OctahedronWrap(normal.xy);normal.xy=normal.xy*.5+.5;return normal.xy;}vec3 M_NormalScale(vec3 normal,float scale){normal.xy*=scale;normal.z=sqrt(1.-clamp(dot(normal.xy,normal.xy),0.,1.));return normal;}float M_HashIGN(vec2 pos){const vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(pos,magic.xy)));}float PBR_DistributionGGX(float cosTheta,float alpha){float a=cosTheta*alpha;float k=alpha/(1.-cosTheta*cosTheta+a*a);return k*k*(1./M_PI);}float PBR_GeometryGGX(float NdotL,float NdotV,float roughness){return .5/mix(2.*NdotL*NdotV,NdotL+NdotV,roughness);}float PBR_SchlickFresnel(float u){float m=1.-u;float m2=m*m;return m2*m2*m;}vec3 PBR_ComputeF0(float metallic,float specular,vec3 albedo){float dielectric=.16*specular*specular;return mix(vec3(dielectric),albedo,vec3(metallic));\n}\n#define LIGHT_FORWARD_COUNT 8\n#define LIGHT_DIR 0\n#define LIGHT_SPOT 1\n#define LIGHT_OMNI 2\nvec3 L_Diffuse(float cLdotH,float cNdotV,float cNdotL,float roughness){float FD90_minus_1=2.*cLdotH*cLdotH*roughness-.5;float FdV=1.+FD90_minus_1*PBR_SchlickFresnel(cNdotV);float FdL=1.+FD90_minus_1*PBR_SchlickFresnel(cNdotL);return vec3(M_INV_PI*(FdV*FdL*cNdotL));}vec3 L_Specular(vec3 F0,float cLdotH,float cNdotH,float cNdotV,float cNdotL,float roughness){roughness=max(roughness,1e-3);float alphaGGX=roughness*roughness;float D=PBR_DistributionGGX(cNdotH,alphaGGX);float G=PBR_GeometryGGX(cNdotL,cNdotV,alphaGGX);float cLdotH5=PBR_SchlickFresnel(cLdotH);float F90=clamp(50.*F0.g,0.,1.);vec3 F=F0+(F90-F0)*cLdotH5;return cNdotL*D*F*G;}struct Light{mat4 matVP;sampler2D shadowMap;samplerCube shadowCubemap;vec3 color;vec3 position;vec3 direction;float specular;float energy;float range;float size;float near;float far;float attenuation;float innerCutOff;float outerCutOff;float shadowSoftness;float shadowMapTxlSz;float shadowDepthBias;float shadowSlopeBias;lowp int type;bool shadow;};noperspective in vec2 vTexCoord;uniform sampler2D uTexAlbedo;uniform sampler2D uTexNormal;uniform sampler2D uTexDepth;uniform sampler2D uTexORM;uniform Light uLight;uniform vec3 uViewPosition;uniform mat4 uMatInvProj;uniform mat4 uMatInvView;layout(location=0)out vec4 FragDiffuse;\nlayout(location=1)out vec4 FragSpecular;\n#define SHADOW_SAMPLES 8\nconst vec2 VOGEL_DISK[8]=vec2[8](vec2(.250000,0.),vec2(-.319290,.292496),vec2(0.048872,-.556877),vec2(.402444,.524918),vec2(-.738535,-.130636),vec2(.699605,-.445031),vec2(-.234004,.870484),vec2(-.446271,-.859268));float ShadowOmni(vec3 position,float cNdotL){vec3 lightToFrag=position-uLight.position;float currentDepth=length(lightToFrag);vec3 direction=normalize(lightToFrag);float bias=uLight.shadowSlopeBias*(1.-cNdotL*.5);bias=max(bias,uLight.shadowDepthBias*currentDepth);currentDepth-=bias;mat3 OBN=M_OrthonormalBasis(direction);float r=M_TAU*M_HashIGN(gl_FragCoord.xy);float sr=sin(r);float cr=cos(r);mat2 diskRot=mat2(vec2(cr,-sr),vec2(sr,cr));float shadow=0.;for(int i=0;i<SHADOW_SAMPLES;++i){vec2 diskOffset=diskRot*VOGEL_DISK[i]*uLight.shadowSoftness;vec3 sampleDir=normalize(OBN*vec3(diskOffset.xy,1.));float sampleDepth=texture(uLight.shadowCubemap,sampleDir).r*uLight.far;shadow+=step(currentDepth,sampleDepth);}return shadow/float(SHADOW_SAMPLES);}float Shadow(vec3 position,float cNdotL){vec4 projPos=uLight.matVP*vec4(position,1.);vec3 projCoords=projPos.xyz/projPos.w*.5+.5;if(any(greaterThan(projCoords.xyz,vec3(1.)))||any(lessThan(projCoords.xyz,vec3(0.)))){return 1.;}float bias=uLight.shadowSlopeBias*(1.-cNdotL);bias=max(bias,uLight.shadowDepthBias*projCoords.z);float currentDepth=projCoords.z-bias;float r=M_TAU*M_HashIGN(gl_FragCoord.xy);float sr=sin(r);float cr=cos(r);mat2 diskRot=mat2(vec2(cr,-sr),vec2(sr,cr));float shadow=0.;for(int i=0;i<SHADOW_SAMPLES;++i){vec2 offset=diskRot*VOGEL_DISK[i]*uLight.shadowSoftness;shadow+=step(currentDepth,texture(uLight.shadowMap,projCoords.xy+offset).r);}return shadow/float(SHADOW_SAMPLES);}vec3 GetPositionFromDepth(float depth){vec4 ndcPos=vec4(vTexCoord*2.-1.,depth*2.-1.,1.);vec4 viewPos=uMatInvProj*ndcPos;viewPos/=viewPos.w;return(uMatInvView*viewPos).xyz;}void main(){vec3 albedo=texture(uTexAlbedo,vTexCoord).rgb;vec3 orm=texture(uTexORM,vTexCoord).rgb;float roughness=orm.g;float metalness=orm.b;vec3 F0=PBR_ComputeF0(metalness,.5,albedo);float depth=texture(uTexDepth,vTexCoord).r;vec3 position=GetPositionFromDepth(depth);vec3 N=M_DecodeOctahedral(texture(uTexNormal,vTexCoord).rg);vec3 V=normalize(uViewPosition-position);float NdotV=dot(N,V);float cNdotV=max(NdotV,1e-4);vec3 L=(uLight.type==LIGHT_DIR)?-uLight.direction:normalize(uLight.position-position);float NdotL=max(dot(N,L),0.);float cNdotL=min(NdotL,1.);vec3 H=normalize(V+L);float LdotH=max(dot(L,H),0.);float cLdotH=min(LdotH,1.);float NdotH=max(dot(N,H),0.);float cNdotH=min(NdotH,1.);vec3 lightColE=uLight.color*uLight.energy;vec3 diffuse=L_Diffuse(cLdotH,cNdotV,cNdotL,roughness);diffuse*=lightColE*(1.-metalness);vec3 specular=L_Specular(F0,cLdotH,cNdotH,cNdotV,cNdotL,roughness);specular*=lightColE*uLight.specular;float shadow=1.;if(uLight.shadow){if(uLight.type!=LIGHT_OMNI)shadow=Shadow(position,cNdotL);else shadow=ShadowOmni(position,cNdotL);}if(uLight.type!=LIGHT_DIR){float dist=length(uLight.position-position);float atten=1.-clamp(dist/uLight.range,0.,1.);shadow*=atten*uLight.attenuation;}if(uLight.type==LIGHT_SPOT){float theta=dot(L,-uLight.direction);float epsilon=(uLight.innerCutOff-uLight.outerCutOff);shadow*=smoothstep(0.,1.,(theta-uLight.outerCutOff)/epsilon);}FragDiffuse=vec4(diffuse*shadow,1.);FragSpecular=vec4(specular*shadow,1.);}";

#define LIGHTING_FRAG_SIZE 6399

#ifdef __cplusplus
}
#endif

#endif // LIGHTING_FRAG_H
